package org.spotitube.Data.Mapper;

import com.microsoft.sqlserver.jdbc.SQLServerDataSource;
import org.spotitube.Data.Context.IConnectionContext;

import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.sql.*;
import java.sql.Date;
import java.util.*;

public abstract class BaseMapper<T> implements IBaseMapper<T> {
    private final IConnectionContext context;

    public BaseMapper(IConnectionContext context) {
        this.context = context;
    }

    /**
     * Saves data to the database using the provided SQL query and query parameters.
     * @param query the SQL query to be executed
     * @param queryParams a list of query parameters to be set in the prepared statement
     * @throws SQLException if an error occurs while executing the SQL query
    */
    @Override
    public void save(String query, List<Object> queryParams) {
        try (Connection conn = context.getConnection();
             PreparedStatement stmt = conn.prepareStatement(query)) {

            // Set query parameters
            for (int i = 0; i < queryParams.size(); i++) {
                stmt.setObject(i + 1, queryParams.get(i));
            }

            // Execute the query
            stmt.executeUpdate();

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    /**
     * Executes a prepared statement with the provided query parameters and returns the result set.
     * @param stmt the prepared statement to execute
     * @param queryParams a list of query parameters to be set in the prepared statement
     * @return the result set generated by executing the query
     * @throws SQLException if an error occurs while executing the prepared statement or setting the query parameters
     * @throws IllegalArgumentException if an unsupported data type is encountered in the query parameters
    */
    private ResultSet executeQuery(PreparedStatement stmt, List<Object> queryParams) throws SQLException {
        // Check if queryParams parameter is set
        if (queryParams.size() >= 1) {
            // Set query parameters
            for (int i = 0; i < queryParams.size(); i++) {
                Object param = queryParams.get(i);
                int parameterIndex = i + 1;

                if (param != null) {
                    switch (param.getClass().getSimpleName()) {
                        case "Integer":
                            stmt.setInt(parameterIndex, (Integer) param);
                            break;
                        case "String":
                            stmt.setString(parameterIndex, (String) param);
                            break;
                        case "Boolean":
                            stmt.setBoolean(parameterIndex, (Boolean) param);
                            break;
                        case "Double":
                            stmt.setDouble(parameterIndex, (Double) param);
                            break;
                        // Add cases for other primitive data types as needed
                        default:
                            // Handle unsupported data type
                            throw new IllegalArgumentException("Unsupported data type: " + param.getClass().getSimpleName());
                    }
                } else {
                    stmt.setNull(parameterIndex, java.sql.Types.NULL);
                }
            }
        }

        // Execute the query
        return stmt.executeQuery();
    }

    /**
     * Retrieves an instance of a generic object from the provided result set using reflection.
     * @param resultSet the result set containing the data to populate the object
     * @return an instance of the generic object with properties set based on the result set data
     * @throws ReflectiveOperationException if an error occurs during object instantiation or property setting
     * @throws SQLException if an error occurs while retrieving data from the result set
    */
    private T getObjectInstance(ResultSet resultSet) throws ReflectiveOperationException, SQLException {
        T result = createInstance();

        // Retrieve and set properties using reflection
        Field[] fields = result.getClass().getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);  // Allow access to private fields

            String columnName = getColumnName(field);  // Get the corresponding column name
            Object columnValue = resultSet.getObject(columnName);

            // Set the value into the field
            if (columnValue instanceof Date) {
                field.set(result, ((Date) columnValue).toLocalDate());
            } else if (columnValue instanceof Short) {
                field.set(result, (Short)columnValue != 0);
            }else{
                field.set(result, columnValue);
            }
        }

        // Retrieve declared fields of the superclass
        Class<?> superClass = result.getClass().getSuperclass();
        if (superClass != null) {
            Field[] superDeclaredFields = superClass.getDeclaredFields();
            for (Field field : superDeclaredFields) {
                field.setAccessible(true);  // Allow access to private fields

                String columnName = getColumnName(field);  // Get the corresponding column name
                Object columnValue = resultSet.getObject(columnName);

                // Set the value into the field and check if value is of type Date or short because Java cannot cast this to LocalDate or boolean on its own because it's a trash language.
                if (columnValue instanceof Date) {
                    field.set(result, ((Date) columnValue).toLocalDate());
                } else if (columnValue instanceof Short) {
                    field.set(result, (Short)columnValue != 0);
                }else{
                    field.set(result, columnValue);
                }
            }
        }

        return result;
    }

    /**
     * Finds and retrieves a single instance of a generic object based on the provided SQL query and query parameters.
     * @param query the SQL query to execute
     * @param queryParams a list of query parameters to be set in the prepared statement
     * @return an Optional containing the retrieved object if it exists, or an empty Optional if no object is found
    */
    @Override
    public Optional<T> find(String query, List<Object> queryParams) {
        try(Connection conn = context.getConnection();
            PreparedStatement stmt = conn.prepareStatement(query)) {

            // Execute query with given queryParams and retrieve resultSet
            ResultSet resultSet = executeQuery(stmt, queryParams);

            // Process the results
            if (resultSet.next()) {
                T result = getObjectInstance(resultSet);
                return Optional.of(result);
            }

        } catch(SQLException | ReflectiveOperationException e) {
            e.printStackTrace();
        }

        return Optional.empty();
    }

    /**
     * Retrieves a list of all instances of a generic object based on the provided SQL query and query parameters.
     * @param query the SQL query to execute
     * @param queryParams a list of query parameters to be set in the prepared statement
     * @return a list containing all retrieved objects
    */
    @Override
    public List<T> all(String query, List<Object> queryParams) {
        List<T> results = new ArrayList<>();

        try(Connection conn = context.getConnection();
        PreparedStatement stmt = conn.prepareStatement(query)){

            // Execute query with given queryParams and retrieve resultSet
            ResultSet resultSet = executeQuery(stmt, queryParams);

            // Process the results
            while(resultSet.next()) {
                T result = getObjectInstance(resultSet);
                results.add(result);
            }

        } catch(SQLException | ReflectiveOperationException e) {
            e.printStackTrace();
        }

        return results;
    }

    /**
     * Creates a new instance of a generic object using reflection.
     * @return a new instance of the generic object
     * @throws ReflectiveOperationException if an error occurs during object instantiation
    */
    protected T createInstance() throws ReflectiveOperationException {
        // Apparently all entity classes need a parameterless constructor otherwise this reflective instantiation method does not work because Java is trash.
        return (T) Class.forName(getClassName()).getDeclaredConstructor().newInstance();
    }


    /**
     * Retrieves the name of the class associated with the generic type parameter.
     * @return the name of the class associated with the generic type parameter
    */
    protected String getClassName() {
        return ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0].getTypeName();
    }

    /**
     * Retrieves the column name associated with the provided Field object, using JavaBeans conventions.
     * @param field the Field object representing a property of the object
     * @return the column name derived from the field name
    */
    protected String getColumnName(Field field) {
        // Use JavaBeans conventions to derive the column name from the field name
        String fieldName = field.getName();
        return Character.toLowerCase(fieldName.charAt(0)) + fieldName.substring(1);
    }
}
